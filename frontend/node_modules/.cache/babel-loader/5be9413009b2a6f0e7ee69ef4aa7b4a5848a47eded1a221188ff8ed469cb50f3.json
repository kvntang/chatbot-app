{"ast":null,"code":"var _jsxFileName = \"/Users/selindursun/Desktop/chatbot-app/frontend/src/components/kevin_gpt3_debug.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport React, { useState, useMemo, useEffect, useRef } from 'react';\nimport { DndContext, DragOverlay, rectIntersection, useDroppable } from '@dnd-kit/core';\nimport { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';\nimport { useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport axios from 'axios';\n\n// MessageBubble Component\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MessageBubble = ({\n  message,\n  isDragging,\n  isHovered\n}) => {\n  if (!message) {\n    return null;\n  }\n\n  // Determine the CSS class based on the sender of the message\n  const bubbleClass = message.sender === 'user' ? 'user-message' : 'bot-message';\n\n  // Handle extra classes for dragging, merged, or hovered messages\n  const draggingClass = isDragging && !message.isMerged ? 'dragging' : '';\n  const mergedClass = message.isMerged ? 'merged-message' : '';\n  const hoveredClass = isHovered ? 'hovered' : '';\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `message-bubble ${bubbleClass} ${draggingClass} ${mergedClass} ${hoveredClass}`,\n    children: message.text\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 31,\n    columnNumber: 5\n  }, this);\n};\n\n// TrashCan Component\n_c = MessageBubble;\nfunction TrashCan() {\n  _s();\n  const {\n    setNodeRef\n  } = useDroppable({\n    id: 'trash-drop'\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: \"trash-drop\",\n    ref: setNodeRef,\n    className: \"trash-can\",\n    children: \"\\uD83C\\uDF42 Forget\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 44,\n    columnNumber: 5\n  }, this);\n}\n\n// SortableMessageBubble Component\n_s(TrashCan, \"cRxoCnej0Qm2GWGzi2a2LoWImLI=\", false, function () {\n  return [useDroppable];\n});\n_c2 = TrashCan;\nconst SortableMessageBubble = ({\n  message,\n  activeId,\n  overId\n}) => {\n  _s2();\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition\n  } = useSortable({\n    id: message.id,\n    animateLayoutChanges: () => false // Disable layout animations to prevent ResizeObserver errors\n  });\n  const style = useMemo(() => ({\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: message.id === activeId ? 0 : 1,\n    // Hide the original item when dragging\n    zIndex: message.id === activeId ? 1000 : 'auto' // Ensure the dragged item is above others\n  }), [transform, transition, activeId, message.id]);\n\n  // Determine if the message is being hovered over\n  const isHovered = message.id === overId && activeId;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: setNodeRef,\n    style: style,\n    ...attributes,\n    ...listeners,\n    children: /*#__PURE__*/_jsxDEV(MessageBubble, {\n      message: message,\n      isDragging: message.id === activeId,\n      isHovered: isHovered\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 78,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 77,\n    columnNumber: 5\n  }, this);\n};\n\n// ChatBox Component\n_s2(SortableMessageBubble, \"y+E3NRJDOZzO0TbGC6g3ImqkM0M=\", false, function () {\n  return [useSortable];\n});\n_c3 = SortableMessageBubble;\nconst ChatBox = () => {\n  _s3();\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n\n  // State for tracking the active draggable item\n  const [activeId, setActiveId] = useState(null);\n  const [overId, setOverId] = useState(null); // New state for hovered item\n\n  // Ref for the messages end\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to the bottom when messages change\n  useEffect(() => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: 'smooth'\n    });\n  }, [messages]);\n  const handleInputChange = e => {\n    setInputValue(e.target.value);\n  };\n  const handleSendMessage = async () => {\n    if (inputValue.trim() === '') return;\n    const newMessage = {\n      id: Date.now().toString(),\n      text: inputValue,\n      sender: 'user'\n    };\n    const fetchGenericBotResponse = async (messages, inputValue) => {\n      const messageHistory = [...messages.map(msg => ({\n        role: msg.sender === 'user' ? 'user' : 'assistant',\n        content: msg.text\n      })), {\n        role: 'user',\n        content: inputValue\n      }];\n      try {\n        const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/generic_bot`, {\n          messageHistory\n        });\n        return {\n          id: (Date.now() + 1).toString(),\n          text: response.data.reply,\n          sender: 'bot'\n        };\n      } catch (error) {\n        console.error('Error fetching reply from the backend:', error);\n        return null;\n      }\n    };\n    setMessages(prevMessages => [...prevMessages, {\n      ...newMessage,\n      order: prevMessages.length + 1\n    }]);\n    setInputValue('');\n    const genericBotReply = await fetchGenericBotResponse(messages, inputValue);\n    if (genericBotReply) {\n      setMessages(prevMessages => [...prevMessages, {\n        ...genericBotReply,\n        order: prevMessages.length + 1\n      }]);\n    }\n  };\n  const updateMessageOrder = messages => {\n    return messages.map((msg, index) => ({\n      ...msg,\n      order: index + 1\n    }));\n  };\n\n  // Helper function to get the opposite sender\n  const getOppositeSender = sender => {\n    return sender === 'user' ? 'bot' : 'user';\n  };\n\n  // Function to merge messages via API\n  const mergeMessagesViaAPI = async (message1, message2) => {\n    const messageHistory = [{\n      role: 'user',\n      content: message1\n    }, {\n      role: 'user',\n      content: message2\n    }];\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/merge`, {\n        messageHistory\n      });\n      console.log('Sent to merge API');\n      return response.data.reply; // Adjust based on your API's response structure\n    } catch (error) {\n      var _error$response;\n      console.error('Error merging messages:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n      return `${message1} ${message2}`;\n    }\n  };\n\n  // Function to generate future user messages via API\n  const generateFutureUserMessage = async messageHistory => {\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/user`, {\n        messageHistory\n      });\n      console.log('Generating future user message');\n      return {\n        id: Date.now().toString(),\n        text: response.data.reply,\n        // Adjust based on your API's response structure\n        sender: 'user'\n      };\n    } catch (error) {\n      var _error$response2;\n      console.error('Error generating future user message:', ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data) || error.message);\n      return null;\n    }\n  };\n\n  // Function to generate future bot messages via API\n  const generateFutureBotMessage = async messageHistory => {\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/bot`, {\n        messageHistory\n      });\n      return {\n        id: Date.now().toString(),\n        text: response.data.reply,\n        // Adjust based on your API's response structure\n        sender: 'bot'\n      };\n    } catch (error) {\n      var _error$response3;\n      console.error('Error generating future bot message:', ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data) || error.message);\n      return null;\n    }\n  };\n\n  // Function to merge and update messages\n  const mergeAndUpdateMessages = async (messages, activeId, overId) => {\n    const activeIndex = messages.findIndex(msg => msg.id === activeId);\n    const overIndex = messages.findIndex(msg => msg.id === overId);\n    if (activeIndex === -1 || overIndex === -1) return messages;\n    const activeMessage = messages[activeIndex];\n    const overMessage = messages[overIndex];\n\n    // Get merged text via API\n    const mergedText = await mergeMessagesViaAPI(overMessage.text, activeMessage.text);\n    const mergedMessage = {\n      ...overMessage,\n      text: mergedText,\n      isMerged: true\n    };\n\n    // Keep messages before the merged message\n    const messagesBeforeMerged = messages.slice(0, Math.min(activeIndex, overIndex));\n\n    // Determine how many new messages to generate\n    const messagesToGenerateCount = messages.length - messagesBeforeMerged.length - 2;\n\n    // Generate new messages asynchronously\n    const startingSender = getOppositeSender(mergedMessage.sender);\n    const newReplies = [];\n    for (let i = 0; i < messagesToGenerateCount; i++) {\n      const sender = i % 2 === 0 ? startingSender : getOppositeSender(startingSender);\n\n      // Build the message history up to this point\n      const messageHistory = [...messagesBeforeMerged.map(msg => ({\n        role: msg.sender === 'user' ? 'user' : 'assistant',\n        content: msg.text\n      })), {\n        role: mergedMessage.sender === 'user' ? 'user' : 'assistant',\n        content: mergedMessage.text\n      }, ...newReplies.map(msg => ({\n        role: msg.sender === 'user' ? 'user' : 'assistant',\n        content: msg.text\n      }))];\n\n      // Generate the next message using the appropriate API\n      let newMessage;\n      if (sender === 'user') {\n        newMessage = await generateFutureUserMessage(messageHistory);\n      } else {\n        newMessage = await generateFutureBotMessage(messageHistory);\n      }\n      if (newMessage) {\n        newReplies.push(newMessage);\n      } else {\n        // Stop generating messages if there's an error\n        break;\n      }\n    }\n\n    // Assemble the updated messages\n    const updatedMessages = [...messagesBeforeMerged, mergedMessage, ...newReplies];\n    return updatedMessages;\n  };\n\n  // Drag event handlers\n  const handleDragStart = event => {\n    const {\n      active\n    } = event;\n    setActiveId(active.id);\n  };\n\n  // New handleDragOver function\n  const handleDragOver = event => {\n    const {\n      over\n    } = event;\n    if (over) {\n      setOverId(over.id);\n    } else {\n      setOverId(null);\n    }\n  };\n  const handleDragEnd = async event => {\n    const {\n      active,\n      over\n    } = event;\n    setActiveId(null);\n    setOverId(null); // Reset overId when drag ends\n\n    if (!over || active.id === over.id) {\n      return;\n    }\n    console.log('Dropped over:', over.id);\n    let reorderedMessages;\n\n    // If dropped over the trash can\n    if (over.id === 'trash-drop') {\n      reorderedMessages = messages.filter(msg => msg.id !== active.id);\n      setMessages(updateMessageOrder(reorderedMessages));\n      return;\n    }\n    // If dropped over another message, merge them\n    else {\n      // Merge messages and generate new ones via API\n      reorderedMessages = await mergeAndUpdateMessages(messages, active.id, over.id);\n      setMessages(updateMessageOrder(reorderedMessages));\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-box\",\n    children: [/*#__PURE__*/_jsxDEV(DndContext, {\n      collisionDetection: rectIntersection,\n      onDragStart: handleDragStart,\n      onDragOver: handleDragOver // Added this line\n      ,\n      onDragEnd: handleDragEnd,\n      children: [/*#__PURE__*/_jsxDEV(SortableContext, {\n        items: messages.map(message => message.id),\n        strategy: verticalListSortingStrategy,\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"messages-container\",\n          children: [messages.map(message => /*#__PURE__*/_jsxDEV(SortableMessageBubble, {\n            message: message,\n            activeId: activeId,\n            overId: overId // Pass overId to SortableMessageBubble\n          }, message.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 386,\n            columnNumber: 15\n          }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n            ref: messagesEndRef\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 394,\n            columnNumber: 13\n          }, this), activeId && /*#__PURE__*/_jsxDEV(TrashCan, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 396,\n            columnNumber: 26\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 384,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 380,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(DragOverlay, {\n        children: activeId ? messages.find(message => message.id === activeId) ? /*#__PURE__*/_jsxDEV(MessageBubble, {\n          message: messages.find(message => message.id === activeId),\n          isDragging: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 402,\n          columnNumber: 15\n        }, this) : null : null\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 399,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 374,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"input-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        value: inputValue,\n        onChange: handleInputChange,\n        placeholder: \"Type your message...\",\n        onKeyPress: e => e.key === 'Enter' && handleSendMessage()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 411,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleSendMessage,\n        children: \"Send\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 418,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 410,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 373,\n    columnNumber: 5\n  }, this);\n};\n_s3(ChatBox, \"PIeKSb4SJsYj1UULjgDXs/aVm+8=\");\n_c4 = ChatBox;\nexport default ChatBox;\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"MessageBubble\");\n$RefreshReg$(_c2, \"TrashCan\");\n$RefreshReg$(_c3, \"SortableMessageBubble\");\n$RefreshReg$(_c4, \"ChatBox\");","map":{"version":3,"names":["React","useState","useMemo","useEffect","useRef","DndContext","DragOverlay","rectIntersection","useDroppable","SortableContext","verticalListSortingStrategy","useSortable","CSS","axios","jsxDEV","_jsxDEV","MessageBubble","message","isDragging","isHovered","bubbleClass","sender","draggingClass","isMerged","mergedClass","hoveredClass","className","children","text","fileName","_jsxFileName","lineNumber","columnNumber","_c","TrashCan","_s","setNodeRef","id","ref","_c2","SortableMessageBubble","activeId","overId","_s2","attributes","listeners","transform","transition","animateLayoutChanges","style","Transform","toString","opacity","zIndex","_c3","ChatBox","_s3","messages","setMessages","inputValue","setInputValue","setActiveId","setOverId","messagesEndRef","_messagesEndRef$curre","current","scrollIntoView","behavior","handleInputChange","e","target","value","handleSendMessage","trim","newMessage","Date","now","fetchGenericBotResponse","messageHistory","map","msg","role","content","response","post","process","env","REACT_APP_API_BASE_URL","data","reply","error","console","prevMessages","order","length","genericBotReply","updateMessageOrder","index","getOppositeSender","mergeMessagesViaAPI","message1","message2","log","_error$response","generateFutureUserMessage","_error$response2","generateFutureBotMessage","_error$response3","mergeAndUpdateMessages","activeIndex","findIndex","overIndex","activeMessage","overMessage","mergedText","mergedMessage","messagesBeforeMerged","slice","Math","min","messagesToGenerateCount","startingSender","newReplies","i","push","updatedMessages","handleDragStart","event","active","handleDragOver","over","handleDragEnd","reorderedMessages","filter","collisionDetection","onDragStart","onDragOver","onDragEnd","items","strategy","find","type","onChange","placeholder","onKeyPress","key","onClick","_c4","$RefreshReg$"],"sources":["/Users/selindursun/Desktop/chatbot-app/frontend/src/components/kevin_gpt3_debug.js"],"sourcesContent":["import React, { useState, useMemo, useEffect, useRef } from 'react';\nimport {\n  DndContext,\n  DragOverlay,\n  rectIntersection,\n  useDroppable,\n} from '@dnd-kit/core';\nimport {\n  SortableContext,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport axios from 'axios';\n\n// MessageBubble Component\nconst MessageBubble = ({ message, isDragging, isHovered }) => {\n  if (!message) {\n    return null;\n  }\n\n  // Determine the CSS class based on the sender of the message\n  const bubbleClass = message.sender === 'user' ? 'user-message' : 'bot-message';\n\n  // Handle extra classes for dragging, merged, or hovered messages\n  const draggingClass = isDragging && !message.isMerged ? 'dragging' : '';\n  const mergedClass = message.isMerged ? 'merged-message' : '';\n  const hoveredClass = isHovered ? 'hovered' : '';\n\n  return (\n    <div className={`message-bubble ${bubbleClass} ${draggingClass} ${mergedClass} ${hoveredClass}`}>\n      {message.text}\n    </div>\n  );\n};\n\n// TrashCan Component\nfunction TrashCan() {\n  const { setNodeRef } = useDroppable({\n    id: 'trash-drop',\n  });\n\n  return (\n    <div id=\"trash-drop\" ref={setNodeRef} className=\"trash-can\">\n      🍂 Forget\n    </div>\n  );\n}\n\n// SortableMessageBubble Component\nconst SortableMessageBubble = ({ message, activeId, overId }) => {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n  } = useSortable({\n    id: message.id,\n    animateLayoutChanges: () => false, // Disable layout animations to prevent ResizeObserver errors\n  });\n\n  const style = useMemo(\n    () => ({\n      transform: CSS.Transform.toString(transform),\n      transition,\n      opacity: message.id === activeId ? 0 : 1, // Hide the original item when dragging\n      zIndex: message.id === activeId ? 1000 : 'auto', // Ensure the dragged item is above others\n    }),\n    [transform, transition, activeId, message.id]\n  );\n\n  // Determine if the message is being hovered over\n  const isHovered = message.id === overId && activeId;\n\n  return (\n    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>\n      <MessageBubble\n        message={message}\n        isDragging={message.id === activeId}\n        isHovered={isHovered}\n      />\n    </div>\n  );\n};\n\n// ChatBox Component\nconst ChatBox = () => {\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n\n  // State for tracking the active draggable item\n  const [activeId, setActiveId] = useState(null);\n  const [overId, setOverId] = useState(null); // New state for hovered item\n\n  // Ref for the messages end\n  const messagesEndRef = useRef(null);\n\n  // Auto-scroll to the bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  const handleInputChange = (e) => {\n    setInputValue(e.target.value);\n  };\n\n  const handleSendMessage = async () => {\n    if (inputValue.trim() === '') return;\n\n    const newMessage = {\n      id: Date.now().toString(),\n      text: inputValue,\n      sender: 'user',\n    };\n\n    const fetchGenericBotResponse = async (messages, inputValue) => {\n      const messageHistory = [\n        ...messages.map((msg) => ({\n          role: msg.sender === 'user' ? 'user' : 'assistant',\n          content: msg.text,\n        })),\n        { role: 'user', content: inputValue },\n      ];\n\n      try {\n        const response = await axios.post(\n          `${process.env.REACT_APP_API_BASE_URL}/generic_bot`,\n          {\n            messageHistory,\n          }\n        );\n\n        return {\n          id: (Date.now() + 1).toString(),\n          text: response.data.reply,\n          sender: 'bot',\n        };\n      } catch (error) {\n        console.error('Error fetching reply from the backend:', error);\n        return null;\n      }\n    };\n\n    setMessages((prevMessages) => [\n      ...prevMessages,\n      { ...newMessage, order: prevMessages.length + 1 },\n    ]);\n\n    setInputValue('');\n\n    const genericBotReply = await fetchGenericBotResponse(messages, inputValue);\n\n    if (genericBotReply) {\n      setMessages((prevMessages) => [\n        ...prevMessages,\n        { ...genericBotReply, order: prevMessages.length + 1 },\n      ]);\n    }\n  };\n\n  const updateMessageOrder = (messages) => {\n    return messages.map((msg, index) => ({\n      ...msg,\n      order: index + 1,\n    }));\n  };\n\n  // Helper function to get the opposite sender\n  const getOppositeSender = (sender) => {\n    return sender === 'user' ? 'bot' : 'user';\n  };\n\n  // Function to merge messages via API\n  const mergeMessagesViaAPI = async (message1, message2) => {\n    const messageHistory = [\n      { role: 'user', content: message1 },\n      { role: 'user', content: message2 },\n    ];\n\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/merge`, {\n        messageHistory,\n      });\n      console.log('Sent to merge API');\n\n      return response.data.reply; // Adjust based on your API's response structure\n    } catch (error) {\n      console.error(\n        'Error merging messages:',\n        error.response?.data || error.message\n      );\n      return `${message1} ${message2}`;\n    }\n  };\n\n  // Function to generate future user messages via API\n  const generateFutureUserMessage = async (messageHistory) => {\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/user`, {\n        messageHistory,\n      });\n\n      console.log('Generating future user message');\n\n      return {\n        id: Date.now().toString(),\n        text: response.data.reply, // Adjust based on your API's response structure\n        sender: 'user',\n      };\n    } catch (error) {\n      console.error(\n        'Error generating future user message:',\n        error.response?.data || error.message\n      );\n      return null;\n    }\n  };\n\n  // Function to generate future bot messages via API\n  const generateFutureBotMessage = async (messageHistory) => {\n    try {\n      const response = await axios.post(`${process.env.REACT_APP_API_BASE_URL}/bot`, {\n        messageHistory,\n      });\n\n      return {\n        id: Date.now().toString(),\n        text: response.data.reply, // Adjust based on your API's response structure\n        sender: 'bot',\n      };\n    } catch (error) {\n      console.error(\n        'Error generating future bot message:',\n        error.response?.data || error.message\n      );\n      return null;\n    }\n  };\n\n  // Function to merge and update messages\n  const mergeAndUpdateMessages = async (messages, activeId, overId) => {\n    const activeIndex = messages.findIndex((msg) => msg.id === activeId);\n    const overIndex = messages.findIndex((msg) => msg.id === overId);\n\n    if (activeIndex === -1 || overIndex === -1) return messages;\n\n    const activeMessage = messages[activeIndex];\n    const overMessage = messages[overIndex];\n\n    // Get merged text via API\n    const mergedText = await mergeMessagesViaAPI(\n      overMessage.text,\n      activeMessage.text\n    );\n\n    const mergedMessage = {\n      ...overMessage,\n      text: mergedText,\n      isMerged: true,\n    };\n\n    // Keep messages before the merged message\n    const messagesBeforeMerged = messages.slice(\n      0,\n      Math.min(activeIndex, overIndex)\n    );\n\n    // Determine how many new messages to generate\n    const messagesToGenerateCount =\n      messages.length - messagesBeforeMerged.length - 2;\n\n    // Generate new messages asynchronously\n    const startingSender = getOppositeSender(mergedMessage.sender);\n    const newReplies = [];\n\n    for (let i = 0; i < messagesToGenerateCount; i++) {\n      const sender =\n        i % 2 === 0 ? startingSender : getOppositeSender(startingSender);\n\n      // Build the message history up to this point\n      const messageHistory = [\n        ...messagesBeforeMerged.map((msg) => ({\n          role: msg.sender === 'user' ? 'user' : 'assistant',\n          content: msg.text,\n        })),\n        {\n          role: mergedMessage.sender === 'user' ? 'user' : 'assistant',\n          content: mergedMessage.text,\n        },\n        ...newReplies.map((msg) => ({\n          role: msg.sender === 'user' ? 'user' : 'assistant',\n          content: msg.text,\n        })),\n      ];\n\n      // Generate the next message using the appropriate API\n      let newMessage;\n      if (sender === 'user') {\n        newMessage = await generateFutureUserMessage(messageHistory);\n      } else {\n        newMessage = await generateFutureBotMessage(messageHistory);\n      }\n\n      if (newMessage) {\n        newReplies.push(newMessage);\n      } else {\n        // Stop generating messages if there's an error\n        break;\n      }\n    }\n\n    // Assemble the updated messages\n    const updatedMessages = [\n      ...messagesBeforeMerged,\n      mergedMessage,\n      ...newReplies,\n    ];\n\n    return updatedMessages;\n  };\n\n  // Drag event handlers\n  const handleDragStart = (event) => {\n    const { active } = event;\n    setActiveId(active.id);\n  };\n\n  // New handleDragOver function\n  const handleDragOver = (event) => {\n    const { over } = event;\n    if (over) {\n      setOverId(over.id);\n    } else {\n      setOverId(null);\n    }\n  };\n\n  const handleDragEnd = async (event) => {\n    const { active, over } = event;\n\n    setActiveId(null);\n    setOverId(null); // Reset overId when drag ends\n\n    if (!over || active.id === over.id) {\n      return;\n    }\n\n    console.log('Dropped over:', over.id);\n\n    let reorderedMessages;\n\n    // If dropped over the trash can\n    if (over.id === 'trash-drop') {\n      reorderedMessages = messages.filter((msg) => msg.id !== active.id);\n      setMessages(updateMessageOrder(reorderedMessages));\n      return;\n    }\n    // If dropped over another message, merge them\n    else {\n      // Merge messages and generate new ones via API\n      reorderedMessages = await mergeAndUpdateMessages(\n        messages,\n        active.id,\n        over.id\n      );\n\n      setMessages(updateMessageOrder(reorderedMessages));\n    }\n  };\n\n  return (\n    <div className=\"chat-box\">\n      <DndContext\n        collisionDetection={rectIntersection}\n        onDragStart={handleDragStart}\n        onDragOver={handleDragOver} // Added this line\n        onDragEnd={handleDragEnd}\n      >\n        <SortableContext\n          items={messages.map((message) => message.id)}\n          strategy={verticalListSortingStrategy}\n        >\n          <div className=\"messages-container\">\n            {messages.map((message) => (\n              <SortableMessageBubble\n                key={message.id}\n                message={message}\n                activeId={activeId}\n                overId={overId} // Pass overId to SortableMessageBubble\n              />\n            ))}\n            {/* Scroll Anchor */}\n            <div ref={messagesEndRef} />\n            {/* Render trash can if something is being dragged */}\n            {activeId && <TrashCan />}\n          </div>\n        </SortableContext>\n        <DragOverlay>\n          {activeId ? (\n            messages.find((message) => message.id === activeId) ? (\n              <MessageBubble\n                message={messages.find((message) => message.id === activeId)}\n                isDragging={true}\n              />\n            ) : null\n          ) : null}\n        </DragOverlay>\n      </DndContext>\n      <div className=\"input-container\">\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={handleInputChange}\n          placeholder=\"Type your message...\"\n          onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}\n        />\n        <button onClick={handleSendMessage}>Send</button>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatBox;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}